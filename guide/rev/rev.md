# Reverse Engineering
Reverse Engineering (RE) problems in CTF are usually designed in such a way which forces the constestants to understand what a program does. The flag of RE problems are usually found when the contestants has found the correct input to the given program. One example of a RE problem might be finding a serial code that is acceptable to the program given.

## Tools
The tools you might need to solve RE problems:
- Debugger ([gdb](http://www.gdbtutorial.com/tutorial/how-install-gdb)) - to RE compiled programs.
- Disassembler ([IDA](https://www.hex-rays.com/products/ida/), [Ghidra](https://ghidra-sre.org/), etc.) - to RE compiled programs.
- SMT Solver ([z3](https://github.com/Z3Prover/z3)) - to solve equations given some constraints.
- etc.

## Example Problem
You can find the file [here](./example/rev).

## How to Solve

### Observation

First off, to know what kind of file it is, we can use:
```
$ file rev
```
```
rev: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-, for GNU/Linux 3.2.0, BuildID[sha1]=6fb9627cbc013322d1595310acf40068382012a4, not stripped
```

We know that it is an ELF executable, usually produced from a compiled C program.

Next, we try to run the program:
```
$ ./rev
```
The program asks for a password, if the password is correct, it will probably give us the flag.

There are numbers of ways to solve this problems:

### Solve #1 - strings

Reverse Engineering problems usually store the flag in the program itself. Most of the time, the flag is encrypted in some ways. When it is not (the flag is stored in plaintext), we can use the `strings` bash command to extract printable strings from the file.
```
$ strings ./rev
```
```
...
UWVS
[^_]
password:
%31s
verygood 						<- the password (?)
;*2$"
CTFGUIDE{th1s_1s_r3v3rs1ing} 	<- the flag
That is not the password.
GCC: (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0
crtstuff.c
...
```
By running the strings command we can see that output is somewhat large, most of these strings are autogenerated by the C compiler. We can directly find the the flag in the form of `CTFGUIDE{}`.

*Note that this method won't work when the flag is encrypted.*

### Solve #3 - gdb

This method uses gdb, a debugging tool, and requires a basic understanding of assembly.
```
$ gdb ./rev
$ disas main
```
```
...
0x080485b4 <+94>:	call   0x8048420 <__isoc99_scanf@plt> 		<- scanf = input
0x080485b9 <+99>:	add    esp,0x10
0x080485bc <+102>:	sub    esp,0x8
0x080485bf <+105>:	lea    eax,[ebx-0x1931]
0x080485c5 <+111>:	push   eax
0x080485c6 <+112>:	lea    eax,[ebp-0x2c]
0x080485c9 <+115>:	push   eax
0x080485ca <+116>:	call   0x80483e0 <strcmp@plt> 				<- strcmp = compares the input to something
...
```
Here we can see the addresses (e.g. 0x080485bc) and instructions (e.g. push eax). This is the logic contained within the program. From our observation, we know that the program asks for an input, compares it to something, if the comparation succeeds, we get the flag. We can set a breakpoint before the `strcmp`	call to know what our input is compared to, that is, the password.
```
$ break *0x080485ca
$ run
```

---

## External Resources
*TBD*